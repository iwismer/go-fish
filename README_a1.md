# Go Fish

Isaac Wismer  
wismeri@uoguelph.ca  
0959337  
CIS*4450 W19  

A simple game of go fish written in python using PyQt5.

## File Structure

### Folders

**ui:** The files that contain the UI design. These can be opened with Qt5 Designer  
**uml:** The UML diagram in XMI and PDF format. Umbrello was used to create the diagram

### Files

**card.py:** The card related classes (Suit, CardValue, Card)  
**deck.py:** The deck related classes (Deck [abstract], PokerDeck)  
**game.py:** The abstract Game class  
**go_fish_gui.py:** This is the main file that runs the whole program.  
**go_fish.py:** The GoFish class, a subclass of Game  
**hand.py:** The Hand class  
**player.py:** The Player class  
**Ui_game_over.py:** The GUI class generated by pyuic for the game over dialog  
**Ui_go_fish.py:** The GUI class for the main window of the game. Generated by pyuic.  

## Building & Running

This project requires Python 3 and and for the module PyQt5 to be installed through pip.  
Generally PyQt5 is installed with the command `pip3 install pyqt5`  
Use a virtual environment if desired.

To run, use the command: `python3 go_fish_gui.py`  
This program has a GUI written in Qt, and does not have a CLI implementation.

## Using the program

The game starts right when you open the program. First, all players put down any pairs that they have in their hands.  
It is always the human player's turn first. Select a card from your hand that you would like to ask for a match for using the radio buttons on the left. Then push a the button for the bot you would like to ask for if they have a card of the same number.  
See the output on the right for the outcome of the ask. If the bot did not have a matching card, you will automatically go fish, and each bot will take their turn. It will then be your turn again. If you did get a match, you will get to go again.  
All bot actions are automatic using my advanced (totally not RNG) AI. You can see the outcome from their turns in their respective output boxes.

## Learning Outcomes

**Design and implement classes for an object-oriented program demonstrating correct use of encapsulation, constructors, method overloading, class invariants, accessors, mutators, instance variables and class variables.**

The class structure of this program is illustrated in the UML diagram in `uml/go_fish_uml.pdf`. Each of the classes in the UML diagram represents a distinct part of the game, and is implemented in this program.  
Encapsulation is demonstrated through the use of Python properties to implement getters and setters. As well, in some cases (eg with the cards in a hand, or the deck of a game), rather than interacting directly with the variable, or with a getter or setter, there are functions that will complete specific required actions. This allows the specific implementation of the action to be hidden from the user. *hand.py lines 31-56, player.py lines 40-144*  
This program does not contain any class (static) variables, as I did not find any places where all instances of a class needed to access to a single variable. For that reason, all variables in this program (with the exception of the code to run the GUI) are instance variables.  
This program does not make use explicit class invariants, although they could be added to allow for greater stability and better testing of the program. Places these could possibly be added are to ensure that there are actually players (or bots) in the game, to ensure that players cannot have a negative wins or ensure that the lists of cards in a deck are all the correct type.

**Construct class hierarchies that maximize code reuse through inheritance while accommodating differences through method overriding.**

There is little inheritance in this program, as it was originally designed to be entirely composition, but will be expanded to include more inheritance to support more games.  
Currently the Game object and Deck classes have sub classes. This allows for multiple types of games to be made with the same API. *game.py, go_fish.py, deck.py*  
Each subclass of deck should be a different kind of deck. Deck itself is abstract because you can't have a generic deck, but you can have types, like a poker deck, an uno deck or a wizard deck. In the same way, you can have different games, like go fish, uno or wizard. I have not yet found a way to make the turn functions generic enough to put in the Deck class, without breaking the Liskov substitution principle. As well, I could also subclass the player class to have a human and bot player to simplify the player code.

**Use polymorphism, abstract methods/classes, and interfaces effectively to produce generic code.**

As a result of the limited use of inheritance, there is also little use of polymorphism, as there aren't any classes that have multiple subclasses.  
Both the Deck and Game classes are abstract, as it does not make sense for either of those generics to be instantiated. The Game class is very bare bones, as I have yet to find a way to make the turn functions generic enough to put in the Deck class, without breaking the Liskov substitution principle. (see above paragraph). *game.py line 12, deck.py line 19*  

**Use event-driven programming to create a usable, effective graphical user interface.**

The interface of this program is very bare bones, and only implements 3 buttons for the user to interact with. These are the buttons for which bot to ask for a card. They use the Qt signal/slot methodology, where an action triggers a signal, which can be received by one or more slots. In this case, there are 3 signals, that all trigger a single function with a different parameter. From there, the player's turn is run. *go_fish_gui.py lines 100, 128-130*

## Assumptions & Limitations

- currently the names of the player and bots cannot be changed
- The number of players and bots cannot be changed
- The player always goes first
- If getting a match from a fish causes the player to play their last card, they will never again pickup

## Next Steps & Possible Improvements

- Make the player class abstract, and make HumanPlayer and BotPlayer subclasses to make the code more generic.
- Find a way to make Game more generic while allowing for different actions during a turn
- Implement more deck and game subclasses
- Improve the usability of the GUI
- Change the turn functions in GoFish to action functions

**Assignment Questions**  
**Q1.** Evaluate the overall submission. Can you set it up and run it with the instructions given in the readme? Is the coding style consistent? Are the filenames reasonable? Is the file/folder structure consistent and understandable? When you run it, are the actions available to you intuitive and usable? Is the purpose of the program clear?

**Q2.** How is the general OO design of the program? Are the classes suitably encapsulated such that implementation details, including instance variables are hidden from client programs?  Are methods designed to do exactly one thing? If overloaded methods exist, has cohesion of purpose been maintained? Has duplicate code been eliminated? Do the classes in the program have exactly one obvious purpose (high cohesion)? (Learning Outcome 1)

**Q3.** Evaluate the relationships between classes. Are the classes appropriate coupled (as opposed to tightly coupled)? If inheritance relationships are present, do they enhance the design?  Is abstraction used correctly? When appropriate, is most abstract type possible is used for variable declarations and function parameters? Is composition used effectively without undue increase of coupling? (Learning Outcomes 2 and 3)

**Q4.** Evaluate the use of event driven programming to produce a graphical user interface. Are Model and View sufficiently decoupled? Are events handled in such a way to reduce coupling and indiscriminate visibility of objects? Does the UI presented respond to events in a predictable, repeatable fashion?
